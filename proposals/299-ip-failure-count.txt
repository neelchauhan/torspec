Filename: 299-ip-failure-count.txt
Title: Preferring IPv4 or IPv6 based on IP Version Failure Count
Author: Neel Chauhan
Created: 25-Jan-2019
Status: Open
Ticket: https://trac.torproject.org/projects/tor/ticket/27491

1. Introduction

   As IPv4 address space becomes scarce, ISPs and organizations will deploy
   IPv6 in their networks. Right now, Tor clients connect to guards using
   IPv4 connectivity by default.

   When networks first transition to IPv6, both IPv4 and IPv6 will be enabled
   on most networks in a so-called "dual-stack" configuration. This is to not
   break existing IPv4-only applications while enabling IPv6 connectivity.
   However, IPv6 connectivity may be unreliable and clients should be able
   to connect to the guard using the most reliable technology, whether IPv4
   or IPv6.

   In ticket #27490, we introduced the option ClientAutoIPv6ORPort which adds
   preliminary "happy eyeballs" support. If set, this lets a client randomly
   choose between IPv4 or IPv6. However, this random decision does not take
   into account unreliable connectivity or network failures of an IP family.
   A successful Tor implementation of the happy eyeballs algorithm requires
   that unreliable connectivity on IPv4 and IPv6 are taken into consideration.

   This proposal describes an algorithm to take into account network failures
   in the random decision used for choosing an IP family and the data fields
   used by the algorithm.

2. Options To Enable The Failure Counter

   To enable the failure counter, we will add a flags to ClientAutoIPv6ORPort.
   The new format for ClientAutoIPv6ORPort is:

      ClientAutoIPv6ORPort 0|1 [flags]

   The first argument is to enable the automatic selection between IPv4 and
   IPv6 if it is 1. The second argument is a list of optional flags.

   The only flag so far is "TrackFailures", which enables the tracking of
   failures to make a better decision when selecting between IPv4 and IPv6.
   The tracking of failures will be described in the rest of this proposal.

   However, we should be open to more flags from future proposals as they
   are written and implemented.

3. Failure Counter Design

   I propose that the failure counter uses the following fields:

      * IPv4 affinity points

      * IPv6 affinity points

   These entries will exist as internal counters for the current session, and
   a calculated value from the previous session in the statefile. 

   These values will be stored as 16-bit unsigned integers for the current
   session and in the statefile.

   When a new session is loaded, we will load the failure count from the
   statefile, and when a session is closed, the failure counts from the current
   session will be stored in the statefile. 

4. Failure Probability Calculation

   A failure of one IP version will increase the probability of the other IP
   version. For instance, a failure of IPv4 will increase the IPv6 probability,
   and vice versa.

   When the IP version is being chosen, I propose that these values will be
   included in the guard selection code:

      * IPv4 affinity points

      * IPv6 affinity points

      * Total summarized affinity points

   These values will be stored as 16-bit unsigned integers.

   A generic failure of an IP version will add one point to the affinity point
   count of the competing IP version to the one which failed.

   We add two affinity points when one (or more) of the following happens:

      * A "no route" warning when communications automatically fail

      * Any permanent failure, such as an unsupported protocol error

   The affinity points for both IPv4 and IPv6 will be stored in the session.
   They are loaded from the statefile at startup, and the current session's
   affinity point values are saved in the statefile when Tor closes.

   The total summarized affinity point count is a sum of the IPv4 and IPv6
   affinity points multiplied with a multiplier for that version's public and
   private IP addresses which will be described in Section 9. This total is
   updated when the affinity point count of an IP version is updated.

   Keep in mind that the affinity point counts are not multiplied on their
   own by the multiplier. This is to accommodate mobile clients which could
   switch between networks that vary in terms of IPv4 and IPv6 support while
   saving the state of affinity point counts.

   The probability of a particular IP version is the affinity points multiplied
   with a multiplier of that version divided by the number of summarized total
   affinity points, multiplied by 4 and stored as an integer. We will call this
   value the summarized affinity point value (SAPV). The reason for this
   summarization is to emulate a probability in 1/4 intervals by the random
   number generator.

   In the random number generator, we will choose a random number between 0
   and 4. If the random number is less than the IPv4 SAPV, we will choose
   IPv4. If it is equal or greater, we will choose IPv6.

   If the probability is 0/4 with a SAPV value of 0, it will be rounded to
   1/4 with a SAPV of 1. Also, if the probability is 4/4 with a SAPV of 4,
   it will be rounded to 3/4 with a SAPV of 3. The reason for this is to
   accomodate mobile clients which could change networks at any time (e.g.
   WiFi to cellular) which may be more or less reliable in terms of a
   particular IP family when compared to the previous network of the client.

5. Initial Failure Point Calculation

   When a client starts without affinity points or if the affinity point value
   drops to 0, we need a SAPV value to start with. The initial SAPV value will
   be counted based on whether the client is using a bridge or not and if the
   relays in the bridge configuration or consensus have IPv6.

   For clients connecting directly to Tor, we will:

      * During Bootstrap: use the number of IPv4 and IPv6 capable fallback
        directory mirrors during bootstrap.

      * After the initial consensus is received: use the number of IPv4 and
        IPv6 capable guards in the consensus.

   The reason why the consensus will be used to calculate the initial affinity
   point value is because using the number of guards would bias the SAPV value
   with whatever's dominant on the network rather than what works on the
   client.

   For clients connecting through bridges, we will use the number of bridges
   configured and the IP versions supported.

   If there are no IPv6 fallback directory mirrors, bridges, or guards, we
   should log a notice once and always choose IPv4. If we have no IPv4
   bridges, should log a notice once and always choose IPv6. This is to
   prevent connection failure messages in the log on the unavailability of
   an IP family.

   The initial value of the affinity points in the scenarios described in this
   section would be:

      * IPv4 Affinity Points: Count the number of IPv4-capable relays

      * IPv6 Affinity Points: Count the number of IPv6-capable relays

   If the consensus or bridge configuration changes during a session, we should
   update the affinity point counters to generate a SAPV.

   If we are starting a new session, we should use the existing affinity points
   to generate a SAPV unless the counts for IPv4 or IPv6 are zero.

6. Forgetting Old Sessions

   We should be able to forget old failures as clients could change networks.
   For instance, a mobile phone could switch between WiFi and cellular. Keeping
   an exact failure history would have privacy implications, so we should store
   an approximate history.

   One way we could forget old sessions is by halving all the affinity point
   (AP) values before adding when:

      * We choose a random number N between 8 and 24, and halve the AP values
        when we have seen N connections. In this case, we repeat this step with
        a new random number

      * One or more affinity point values are greater than or equal to 100

   If the AP value for one IP version goes down to zero, we will re-calculate
   the SAPV for that version using the methods described in Section 4.

7. Increasing Simultaneous Connection Attempts When Bootstrapping

   Right now, Tor limits the number of simultaneous connection attempts when
   bootstrapping to three connections. This is too low for networks that drop
   all IPv4 or all IPv6 packets. This is specified using the option
   ClientBootstrapConsensusMaxInProgressTries.

   I propose the default value of ClientBootstrapConsensusMaxInProgressTries
   is increased to 6. While not exact, this will account for approximately
   three IPv4 connections and three IPv6 connections during bootstrap.

8. Marking Guards As Failed With ClientAutoIPv6ORPort

   If Tor is successful on both IPv4 and IPv6, we should require failures on
   both IPv4 and IPv6 connections before marking a guard as failed.

   If we are successful on only one protocol (IPv4 or IPv6), we should only
   require a failure on that protocol to mark a guard as failed.

9. Counting Public and Private IP Addresses

   In Ticket #27492, we plan to increase the probability of an IP family based
   on how many internal or external IP addresses a client machine has.

   This will be implemented as two values to be used as multipliers to the
   affinity values. The values are as follows:

      * IPv4 Affinity Point Multiplier

      * IPv6 Affinity Point Multiplier

   The rules for these multipliers are as follows:

      * If we have a public IP address, we add two to the multiplier for the
        version of the IP address being evaluated

      * If we have a private IP address, we add two to the multiplier for the
        version of the IP address being evaluated unless the "private" address
        is link-local IPv6

   For instance, if a client has one public IPv6 address and one private IPv4
   address, we add two to the IPv6 multiplier, and one to the IPv4 multiplier.

   The multiplier for an IP version is multiplied into the affinity point
   counts of that version when calculating its SAPV or summarized total as
   per Section 4 of this proposal. Keep in mind that we do not multiply the
   IPv4 or IPv6 affinity point values itself. This allows us to accommodate
   mobile clients which could change networks that vary in terms of IPv4
   and IPv6 support while saving affinity point counts in the state file.

10. Counting Successful Connections

   If a connection to a particular IP version is successful, we should use
   it. This ensures that clients have a reliable connection to Tor. Accounting
   for successful connections can be done by adding one affinity point to the
   successful connection's IP version. For instance, if we have a successful
   IPv6 connection, we add one IPv6 affinity point. This increases the chances
   of using IP versions that work.

   Even on adding successes, we will still halve the failure counters as
   described in Section 5.

11. Acknowledgements

   Thank you teor for aiding me with the implementation of Happy Eyeballs in
   Tor. This would not have been possible if it weren't for you.
